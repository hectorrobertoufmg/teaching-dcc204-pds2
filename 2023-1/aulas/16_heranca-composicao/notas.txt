           ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
              NOTAS DE AULA - 15 POO: HERANÇA E COMPOSIÇÃO
                               (PARTE 1)

                           Luigi D. C. Soares
           ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━





Herança vs Composição (Recapitulando)
═════════════════════════════════════

  • Herança modela uma relação do tipo *é um* (is-a)
  • Composição modela uma relação do tipo *tem um* (has-a)

  Como escolher entre herança e composição?

  • O tipo B vai manter todo o contrato do A, e poderá ser usado onde A
    é esperado (Princípio de Substituição de Liskov)? Se sim, *herança*
  • O tipo B deseja apenas utilizar *parte* do comportamento exposto
    pelo tipo A? Então, *composição*

  Algumas recomendações para o uso de herança:

  • Mova interfaces, dados e comportamentos comuns o mais alto possível
    na hierarquia
  • Suspeite e classes base com apenas uma classe derivada
  • Evite hierarquia muito profundas (aumenta acoplamento)
  • Atenção ao encapsulamento: para cada membro da classe base, ele será
    visível na classe derivada?


Classes e Métodos Abstratos
═══════════════════════════

  • Uma classe abstrata *não pode ser instanciada*, ela apenas
    representa um conceito abstrato

    Exemplo: uma classe Numero abstrai o conceito de números. Números
    podem ser do tipo Inteiro ou Real, que são subclasses. Nós
    instanciamos um Inteiro/Real, não um Numero genérico.

  • Um *método* abstrato normalmente é um método que não possui
    implementação, apenas um *contrato*. Em C++, isso vai ser um pouco
    mais "fraco": um método será abstrato se exigir que classes
    derivadas o implementem.
  • Classes que possuem pelo menos um método abstrato são classes
    abstratas
  • Subclasses de uma classe abstrata devem implementar os métodos
    abstratos que a superclasse define (ou se tornarão abstratas também)

  Algumas linguagens, como Java, possuem uma palavra-chave para classes
  e métodos abstratos. Em C++, vamos usar a palavra-chave `virtual'.

  Uma classe abstrata, em C++, é uma classe que possui pelo menos um
  método *virtual puro*:

  ┌────
  │ #include <iostream>
  │ #include <string>
  │ 
  │ class Animal {
  │ public:
  │   Animal(std::string name) : name_(name) {}
  │   void eat() {
  │     std::cout << name_ << " is eating." << std::endl;
  │   }
  │   virtual void say() = 0;
  │   virtual ~Animal() {}
  │ 
  │ protected:
  │   std::string name_;
  │ };
  │ 
  │ class Dog : public Animal {
  │ public:
  │   Dog(std::string name) : Animal(name) {}
  │   void say() {
  │     std::cout << name_ << " says woof!" << std::endl;
  │   }
  │ };
  │ 
  │ class Cat : public Animal {
  │ public:
  │   Cat(std::string name) : Animal(name) {}
  │   void say() {
  │     std::cout << name_ << " says meow!" << std::endl;
  │   }
  │ };
  │ 
  │ int main() {
  │   // error: cannot declare variable ‘a’ to be of abstract type ‘Animal’
  │   // Animal a("dog");
  │ 
  │   Animal *dog = new Dog("dog");
  │   Animal *cat = new Cat("cat");
  │ 
  │   dog->eat();
  │   dog->say();
  │ 
  │   std::cout << std::endl;
  │ 
  │   cat->eat();
  │   cat->say();
  │ 
  │   delete dog;
  │   delete cat;
  │ 
  │   return 0;
  │ }
  └────

  Uma classe abstrata não necessariamente precisa ter algum método
  abstrato. Em outras linguagens isso é mais claro, em C++ uma classe
  abstrata precisa ter pelo menos um método virtual puro. Porém, em C++
  métodos virtuais puros podem ter um corpo (note que, ainda assim, é
  necessário que classes derivadas o implementem! Não estamos quebrando
  a definição vista acima).

  Para definir uma classe abstrata "sem" métodos abstratos em C++,
  podemos declarar o destrutor como virtual puro. Ainda que você não
  implemente o destrutor nas classes derivadas, o compilador vai gerar
  um destrutor padrão, então vai funcionar!

  ┌────
  │ #include <iostream>
  │ 
  │ class A {
  │ public:
  │   void foo() {
  │     std::cout << "Foo" << std::endl;
  │   }
  │   virtual ~A() = 0; // pure virtual destructor, "abstract"
  │ };
  │ 
  │ A::~A() {}
  │ 
  │ class B : public A {};
  │ 
  │ int main() {
  │   // error: cannot declare variable ‘a’ to be of abstract type ‘A’
  │   // A a;
  │   B b;
  │   b.foo();
  │   return 0;
  │ }
  └────

  *Importante:* é uma boa prática sempre declarar o destrutor como
   virtual quando existe algum outro método virtual (mesmo que não puro)
  • Por quê?
  • Lembra do que acontece quando chamamos um método não-virtual usando
    um ponteiro para a classe Base?

    ┌────
    │ #include <iostream>
    │ 
    │ class Base {
    │ public:
    │   ~Base() {
    │     std::cout << "~Base()" << std::endl;
    │   }
    │ };
    │ 
    │ class Derivada : public Base {
    │ public:
    │   ~Derivada() {
    │     std::cout << "~Derivada()" << std::endl;
    │   }
    │ };
    │ 
    │ int main() {
    │   Base *b = new Derivada();
    │   delete b;
    │   return 0;
    │ }
    └────

  O destrutor chamado foi apenas o da Base!!! Ou seja, objetos que
  precisariam ser destruídos na classe Derivada não serão!

  Com destrutor virtual:

  ┌────
  │ #include <iostream>
  │ 
  │ class Base {
  │ public:
  │   virtual ~Base() {
  │     std::cout << "~Base()" << std::endl;
  │   }
  │ };
  │ 
  │ class Derivada : public Base {
  │ public:
  │   ~Derivada() {
  │     std::cout << "~Derivada()" << std::endl;
  │   }
  │ };
  │ 
  │ int main() {
  │   Base *b = new Derivada();
  │   delete b;
  │   return 0;
  │ }
  └────


Interfaces
══════════

  • Possuem unicamente o papel de um *contrato*
  • Uma interface "I" descreve tudo que um objeto precisa implementar
    para ser considerado um "I"
  • Uma interface possui apenas a declaração *operações públicas* (sem
    dados, sem modificadores protected e private)
  • Algumas linguagens (e.g. Java) possuem uma palavra-chave para a
    definição de interfaces. Não é o caso de C++. Em C++, não existe uma
    distinção sintática entre classe abstrata e interface, apenas
    distinção semântica: uma interface é uma classe que contém *apenas*
    métodos puramente virtuais.

  Exemplo: Um MusicPlayer e um VideoPlayer possuem alguns comportamentos
  em comum. Quais?

  ┌────
  │ #include <iostream>
  │ 
  │ // Interface
  │ class Playable {
  │ public:
  │   virtual void play() = 0;
  │   virtual void pause() = 0;
  │ 
  │   // Toda interface deve implementar um destrutor virtual!
  │   virtual ~Playable() {} 
  │ };
  │ 
  │ // MusicPlayer *é* Playable
  │ class MusicPlayer : public Playable {
  │ public:
  │   void play() {
  │     std::cout << "Music is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Music playback paused." << std::endl;
  │   }
  │ };
  │ 
  │ // VideoPlayer *é* Playable
  │ class VideoPlayer : public Playable {
  │ public:
  │   void play() {
  │     std::cout << "Video is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Video playback paused." << std::endl;
  │   }
  │ };
  │ 
  │ int main() {
  │   MusicPlayer mp;
  │   mp.play();
  │   mp.pause();
  │ 
  │   VideoPlayer vp;
  │   vp.play();
  │   vp.pause();
  │ 
  │   return 0;
  │ }
  └────

  MusicPlayer e VideoPlayer poderiam, também, ter uma função de gravar.
  • Faz sentido colocar esta operação em `Playable'?
  • Podemos ter uma classe implementado duas interfaces? Herança
    múltipla (um caso que faz sentido!)

  ┌────
  │ #include <iostream>
  │ 
  │ // Interface
  │ class Playable {
  │ public:
  │   virtual void play() = 0;
  │   virtual void pause() = 0;
  │ 
  │   // Toda interface deve implementar um destrutor virtual!
  │   virtual ~Playable() {} 
  │ };
  │ 
  │ // Outra interface
  │ class Recordable {
  │ public:
  │   virtual void record() = 0;
  │   virtual ~Recordable() {}
  │ };
  │ 
  │ // MusicPlayer *é* Playable
  │ class MusicPlayer : public Playable, public Recordable {
  │ public:
  │   void play() {
  │     std::cout << "Music is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Music playback paused." << std::endl;
  │   }
  │ };
  │ 
  │ // VideoPlayer *é* Playable
  │ class VideoPlayer : public Playable, public Recordable {
  │ public:
  │   void play() {
  │     std::cout << "Video is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Video playback paused." << std::endl;
  │   }
  │ };
  │ 
  │ int main() {
  │   MusicPlayer mp;
  │   mp.play();
  │   mp.pause();
  │ 
  │   VideoPlayer vp;
  │   vp.play();
  │   vp.pause();
  │ 
  │   return 0;
  │ }
  └────

  ┌────
  │ error: cannot declare variable ‘mp’ to be of abstract type ‘MusicPlayer’
  │ error: cannot declare variable ‘vp’ to be of abstract type ‘VideoPlayer’
  └────

  Hmm, o que deu errado? Volte ao código para identificar o que
  esquecemos.

  ┌────
  │ #include <iostream>
  │ 
  │ // Interface
  │ class Playable {
  │ public:
  │   virtual void play() = 0;
  │   virtual void pause() = 0;
  │ 
  │   // Toda interface deve implementar um destrutor virtual!
  │   virtual ~Playable() {} 
  │ };
  │ 
  │ // Outra interface
  │ class Recordable {
  │ public:
  │   virtual void record() = 0;
  │   virtual ~Recordable() {}
  │ };
  │ 
  │ // MusicPlayer *é* Playable
  │ class MusicPlayer : public Playable, public Recordable {
  │ public:
  │   void play() {
  │     std::cout << "Music is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Music playback paused." << std::endl;
  │   }
  │ 
  │   void record() {
  │     std::cout << "Recording music." << std::endl;
  │   }
  │ };
  │ 
  │ // VideoPlayer *é* Playable
  │ class VideoPlayer : public Playable, public Recordable {
  │ public:
  │   void play() {
  │     std::cout << "Video is playing." << std::endl;
  │   }
  │ 
  │   void pause() {
  │     std::cout << "Video playback paused." << std::endl;
  │   }
  │ 
  │   void record() {
  │     std::cout << "Recording video." << std::endl;
  │   }
  │ };
  │ 
  │ int main() {
  │   MusicPlayer mp;
  │   mp.play();
  │   mp.record();
  │   mp.pause();
  │ 
  │   VideoPlayer vp;
  │   vp.play();
  │   vp.record();
  │   vp.pause();
  │ 
  │   return 0;
  │ }
  └────


+ Boas Práticas: SOLID
══════════════════════

  Vimos anteriormente o Princípio da Responsabilidade Única (SRP), o "S"
  de SOLID. Vamos retomar o exemplo que utilizamos:

  ┌────
  │ #include <iostream>
  │ #include <map>
  │ #include <vector>
  │ 
  │ struct Item {
  │   unsigned code;
  │   std::string name;
  │   float price;
  │ };
  │ 
  │ class Order {
  │ public:
  │   enum class Status { open, paid };
  │   Status status = Status::open;
  │ 
  │   void add_item(Item item) {
  │     _items_quantities.insert({item, 0});
  │     _items_quantities[item]++;
  │   }
  │ 
  │   float total_price() const {
  │     float total = 0.0;
  │     for (auto [item, quantity] : _items_quantities) {
  │       total += item.price * quantity;
  │     }
  │     return total;
  │   }
  │ 
  │ private:
  │   class _ItemComparator {
  │   public:
  │     bool operator()(const Item &a, const Item &b) const {
  │       return a.name < b.name;
  │     }
  │   };
  │ 
  │   std::map<Item, unsigned, _ItemComparator> _items_quantities;
  │ };
  │ 
  │ class PaymentProcessor {
  │ public:
  │   void pay(std::string payment_type, Order &order) {
  │     if (payment_type == "debit") {
  │       std::cout << "Processing debit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     } else if (payment_type == "credit") {
  │       std::cout << "Processing credit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     }
  │   }
  │ };
  │ 
  │ int main() {
  │   Order order;
  │ 
  │   order.add_item({0, "Notebook", 5000.50});
  │   order.add_item({0, "TV 4K", 8764.50});
  │ 
  │   std::cout << "$" << order.total_price() << std::endl;
  │ 
  │   PaymentProcessor processor;
  │   processor.pay("credit", order);
  │ 
  │   return 0;
  │ }
  └────

  Antes de prosseguir, vamos fazer uma pequena modificação no exemplo:
  tanto pagamento por crédito quanto por débito requer um "código de
  segurança":

  ┌────
  │ #include <iostream>
  │ #include <map>
  │ #include <vector>
  │ 
  │ struct Item {
  │   unsigned code;
  │   std::string name;
  │   float price;
  │ };
  │ 
  │ class Order {
  │ public:
  │   enum class Status { open, paid };
  │   Status status = Status::open;
  │ 
  │   void add_item(Item item) {
  │     _items_quantities.insert({item, 0});
  │     _items_quantities[item]++;
  │   }
  │ 
  │   float total_price() const {
  │     float total = 0.0;
  │     for (auto [item, quantity] : _items_quantities) {
  │       total += item.price * quantity;
  │     }
  │     return total;
  │   }
  │ 
  │ private:
  │   class _ItemComparator {
  │   public:
  │     bool operator()(const Item &a, const Item &b) const {
  │       return a.name < b.name;
  │     }
  │   };
  │ 
  │   std::map<Item, unsigned, _ItemComparator> _items_quantities;
  │ };
  │ 
  │ class PaymentProcessor {
  │ public:
  │   void pay(std::string payment_type, Order &order, std::string security_code) {
  │     std::cout << "Verifying security code: " << security_code << std::endl;
  │     if (payment_type == "debit") {
  │       std::cout << "Processing debit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     } else if (payment_type == "credit") {
  │       std::cout << "Processing credit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     }
  │   }
  │ };
  │ 
  │ int main() {
  │   Order order;
  │ 
  │   order.add_item({0, "Notebook", 5000.50});
  │   order.add_item({0, "TV 4K", 8764.50});
  │ 
  │   std::cout << "$" << order.total_price() << std::endl;
  │ 
  │   PaymentProcessor processor;
  │   processor.pay("credit", order, "123456");
  │ 
  │   return 0;
  │ }
  └────


"O": Open for Extension/Closed for Modification
───────────────────────────────────────────────

  Observe a classe `PaymentProcessor': podemos realizar o pagamento
  tanto por crédito quanto por débito. Suponha que, inicialmente, estas
  eram as duas formas de pagamento disponíveis. O sistema está
  funcionando como deveria já há algum tempo. Eventualmente, uma nova
  forma de pagamento é solicitada: PayPal. Note que PayPal não utiliza
  código de segurança, mas sim um endereço de email.

  Como implementar?

  ┌────
  │ #include <iostream>
  │ #include <map>
  │ #include <vector>
  │ 
  │ struct Item {
  │   unsigned code;
  │   std::string name;
  │   float price;
  │ };
  │ 
  │ class Order {
  │ public:
  │   enum class Status { open, paid };
  │   Status status = Status::open;
  │ 
  │   void add_item(Item item) {
  │     _items_quantities.insert({item, 0});
  │     _items_quantities[item]++;
  │   }
  │ 
  │   float total_price() const {
  │     float total = 0.0;
  │     for (auto [item, quantity] : _items_quantities) {
  │       total += item.price * quantity;
  │     }
  │     return total;
  │   }
  │ 
  │ private:
  │   class _ItemComparator {
  │   public:
  │     bool operator()(const Item &a, const Item &b) const {
  │       return a.name < b.name;
  │     }
  │   };
  │ 
  │   std::map<Item, unsigned, _ItemComparator> _items_quantities;
  │ };
  │ 
  │ class PaymentProcessor {
  │ public:
  │   void pay(std::string payment_type, Order &order, std::string security_code) {
  │     std::cout << "Verifying email address: " << security_code << std::endl;
  │     if (payment_type == "debit") {
  │       std::cout << "Processing debit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     } else if (payment_type == "credit") {
  │       std::cout << "Processing credit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     } else if (payment_type == "paypal") {
  │       std::cout << "Processing paypal payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │     }
  │   }
  │ };
  │ 
  │ int main() {
  │   Order order;
  │ 
  │   order.add_item({0, "Notebook", 5000.50});
  │   order.add_item({0, "TV 4K", 8764.50});
  │ 
  │   std::cout << "$" << order.total_price() << std::endl;
  │ 
  │   PaymentProcessor processor;
  │   processor.pay("paypal", order, "lebron.james@gmail.com");
  │ 
  │   return 0;
  │ }
  └────

  Você consegue perceber algo estranho? Este é um exemplo ilustrativo,
  em um sistema real existiria, de fato, verificações do código de
  segurança. Mas, acabamos de trocar (acidentalmente) esta verificação
  por uma verificação de endereço de email. Agora, clientes antigos da
  classe PaymentProcessor irão parar de funcionar!!!

  O ponto aqui é: a classe PaymentProcessor funcionava como deveria,
  estava estável! Qualquer mudança que a gente realize na implementação
  desta classe pode quebrar o funcionamento, impactando clientes que já
  utilizam a classe há muito tempo!

  Isto nos leva ao princípio Open/Closed: uma classe deve ser *fechada
  para modificações* e *aberta para extensões*.

  Como refatorar? Podemos transformar PaymentProcessor em uma interface!

  ┌────
  │ #include <iostream>
  │ #include <map>
  │ #include <vector>
  │ 
  │ struct Item {
  │   unsigned code;
  │   std::string name;
  │   float price;
  │ };
  │ 
  │ class Order {
  │ public:
  │   enum class Status { open, paid };
  │   Status status = Status::open;
  │ 
  │   void add_item(Item item) {
  │     _items_quantities.insert({item, 0});
  │     _items_quantities[item]++;
  │   }
  │ 
  │   float total_price() const {
  │     float total = 0.0;
  │     for (auto [item, quantity] : _items_quantities) {
  │       total += item.price * quantity;
  │     }
  │     return total;
  │   }
  │ 
  │ private:
  │   class _ItemComparator {
  │   public:
  │     bool operator()(const Item &a, const Item &b) const {
  │       return a.name < b.name;
  │     }
  │   };
  │ 
  │   std::map<Item, unsigned, _ItemComparator> _items_quantities;
  │ };
  │ 
  │ class PaymentProcessor {
  │ public:
  │   virtual void pay(Order &order, std::string security_code) = 0;
  │   virtual ~PaymentProcessor() {}
  │ };
  │ 
  │ class DebitPaymentProcessor : public PaymentProcessor {
  │ public:
  │   void pay(Order &order, std::string security_code) {
  │       std::cout << "Verifying security code: " << security_code << std::endl;
  │       std::cout << "Processing debit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ };
  │ 
  │ class CreditPaymentProcessor : public PaymentProcessor {
  │ public:
  │   void pay(Order &order, std::string security_code) {
  │       std::cout << "Verifying security code: " << security_code << std::endl;
  │       std::cout << "Processing credit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ };
  │ 
  │ class PaypalPaymentProcessor : public PaymentProcessor {
  │ public:
  │   void pay(Order &order, std::string email) {
  │       std::cout << "Verifying email adress: " << email << std::endl;
  │       std::cout << "Processing paypal payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ };
  │ 
  │ int main() {
  │   Order order;
  │ 
  │   order.add_item({0, "Notebook", 5000.50});
  │   order.add_item({0, "TV 4K", 8764.50});
  │ 
  │   std::cout << "$" << order.total_price() << std::endl;
  │ 
  │   PaymentProcessor *processor = new PaypalPaymentProcessor();
  │   processor->pay(order, "lebron.james@gmail.com");
  │ 
  │   delete processor;
  │   return 0;
  │ }
  └────

  *Importante: você não deve levar este princípio ao pé da letra*

  • Se levarmos o princípio open/closed ao pé da letra (conforme
    descrito acima), o que faríamos para corrigir um bug no código? Já
    que não podemos modificar o código… não faz sentido! Se existe algo
    errado na classe/módulo, você *deve corrigir*, e não introduzir uma
    nova classe com o comportamento correto, deixando a original
    incorreta.

  • Se você têm controle sobre o software original e pode reescrevê-lo
    de modo a atender novas demandas, *sem causar nenhum problema*, você
    deve fazer.

  O princípio open/closed serve para guiar o design do sistema de modo a
  tornâ-lo facilmente extensível.


"L": Princípio de Substituição de Liskov
────────────────────────────────────────

  Você nota algo ainda estranho na nossa implementação dos diferentes
  meios de pagamento?

  Pense: DebitPaymentProcessor, CreditPaymentProcessor e
  PaypalPaymentProcessor *são* PaymentProcessors. Logo, deveríamos
  conseguir substituir qualquer uso de PaymentProcessor pelas subclasses
  especializadas.

  No nosso exemplo, foi possível utilizar um ponteiro para payment
  processor. Ainda assim, estamos violando um princípio. Esta violação é
  semântica, não sintática! O contrato estabelecido por PaymentProcessor
  diz que o método de pagamento é parametrizado por um pedido e por um
  código de segurança. Mas, paypal não utiliza código de segurança, e
  sim um email!

  Note a diferença:

  ┌────
  │ // (1)
  │ PaymentProcessor *processor = new CreditPaymentProcessor();
  │ processor->pay(order, "123456");
  │ 
  │ // (2)
  │ PaymentProcessor *processor = new DebitPaymentProcessor();
  │ processor->pay(order, "123456");
  │ 
  │ // (3)
  │ PaymentProcessor *processor = new PaypalPaymentProcessor();
  │ processor->pay(order, "lebron.james@gmail.com");
  └────

  (1) e (2) respeitam a semântica do contrato estabelecido por
  PaymentProcessor. Logo, poderíamos fazer a substituição. Mas, (3) não
  respeita! Ainda estamos passando uma string (sintaticamente correto),
  mas o *significado* dessa string é diferente!

  Estamos ferindo o Princípio de Substituição de Liskov: um objeto de um
  tipo T deve poder ser substituído por um objeto de um subtipo S sem
  alterar nenhuma propriedade do programa. Em outras palavras, "os tipos
  T e S são intercambiáveis?"

  Solucionar este problema no nosso exemplo é trivial, basta remover o
  parâmetro `security_code' da interface:

  ┌────
  │ #include <iostream>
  │ #include <map>
  │ #include <vector>
  │ 
  │ struct Item {
  │   unsigned code;
  │   std::string name;
  │   float price;
  │ };
  │ 
  │ class Order {
  │ public:
  │   enum class Status { open, paid };
  │   Status status = Status::open;
  │ 
  │   void add_item(Item item) {
  │     _items_quantities.insert({item, 0});
  │     _items_quantities[item]++;
  │   }
  │ 
  │   float total_price() const {
  │     float total = 0.0;
  │     for (auto [item, quantity] : _items_quantities) {
  │       total += item.price * quantity;
  │     }
  │     return total;
  │   }
  │ 
  │ private:
  │   class _ItemComparator {
  │   public:
  │     bool operator()(const Item &a, const Item &b) const {
  │       return a.name < b.name;
  │     }
  │   };
  │ 
  │   std::map<Item, unsigned, _ItemComparator> _items_quantities;
  │ };
  │ 
  │ class PaymentProcessor {
  │ public:
  │   virtual void pay(Order &order) = 0;
  │   virtual ~PaymentProcessor() {}
  │ };
  │ 
  │ class DebitPaymentProcessor : public PaymentProcessor {
  │ public:
  │   DebitPaymentProcessor(std::string security_code)
  │     : _security_code(security_code) {}
  │ 
  │   void pay(Order &order) {
  │       std::cout << "Verifying security code: " << _security_code << std::endl;
  │       std::cout << "Processing debit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ 
  │ private:
  │   std::string _security_code;
  │ };
  │ 
  │ class CreditPaymentProcessor : public PaymentProcessor {
  │ public:
  │   CreditPaymentProcessor(std::string security_code)
  │     : _security_code(security_code) {}
  │ 
  │   void pay(Order &order) {
  │       std::cout << "Verifying security code: " << _security_code << std::endl;
  │       std::cout << "Processing credit payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ 
  │ private:  
  │   std::string _security_code;
  │ };
  │ 
  │ class PaypalPaymentProcessor : public PaymentProcessor {
  │ public:
  │   PaypalPaymentProcessor(std::string email)
  │     : _email(email) {}
  │ 
  │   void pay(Order &order) {
  │       std::cout << "Verifying email adress: " << _email << std::endl;
  │       std::cout << "Processing paypal payment type" << std::endl;
  │       // Outras coisas...
  │       order.status = Order::Status::paid;
  │   }
  │ 
  │ private:
  │   std::string _email;
  │ };
  │ 
  │ int main() {
  │   Order order;
  │ 
  │   order.add_item({0, "Notebook", 5000.50});
  │   order.add_item({0, "TV 4K", 8764.50});
  │ 
  │   std::cout << "$" << order.total_price() << std::endl;
  │ 
  │   PaymentProcessor *processor = new PaypalPaymentProcessor("lebron.james@gmail.com");
  │   processor->pay(order);
  │ 
  │   delete processor;
  │   return 0;
  │ }
  └────
