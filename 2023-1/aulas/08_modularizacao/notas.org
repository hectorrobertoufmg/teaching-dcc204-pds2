#+title: Notas de Aula - 08 Modulariza√ß√£o
#+author: Luigi D. C. Soares
#
#+startup: entitiespretty
#+options: toc:nil  num:nil
#
* Programa√ß√£o Modular

- O que √©?
  
  "software design technique that emphasizes separating the functionality of a program into *independent*, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality"
  
  (https://en.wikipedia.org/wiki/Modular_programming)
  
- Quando/por qu√™ utilizar?

Queremos agrupar elementos que dizem respeito a uma mesma funcionalidade. Onde j√° vimos isso?
- Classes: agrupamento local (campos)

Ainda assim, classes representam algo bem espec√≠fico (lembram do princ√≠pio de responsabilidade √∫nica? SRP), o que n√£o √© suficiente a medida que o sistema cresce e se torna mais complexo.

Classes possuem diversas rela√ß√µes entre si (voltaremos nisso). Algumas classes est√£o muito "pr√≥ximas", outras mais distantes. Como organiz√°-las? Qual o pr√≥ximo passo?

M√≥dulos!
- Compilado separadamente, independentes (na medida do poss√≠vel... depend√™ncias restritas as interfaces de outros m√≥dulos)
- Reutiliz√°vel e modific√°vel
- SRP ainda se aplica
- Coes√£o: grau de depend√™ncia entre os elementos do m√≥dulo (queremos *alta coes√£o*)
- Acoplamento: grau de depend√™ncia entre diferentes m√≥dulos (queremos *baixo acoplamento*)

E como representar m√≥dulos em C++?

* Namespaces

Onde j√° vimos isso? ~std::~

E como podemos criar nossos pr√≥prios namespaces? Imagine que queremos criar um m√≥dulo de containers

seq.hpp (containers sequenciais)

#+begin_src C++ :main no :tangle seq.hpp
#ifndef CONTAINER_SEQ_H
#define CONTAINER_SEQ_H

namespace container {
template <typename T>
class Vector {
public:
  Vector();
  ~Vector();
  
  void push_back(T e);
  T at(std::size_t i) const;
  
private:
  std::size_t _size;
  std::size_t _capacity;
  T *_vector;
};

template <typename T>
class LinkedList {
  // ...
};
};

#include "vector.tpp"
#endif
#+end_src

vector.tpp (implementando o vector)

#+begin_src C++ :main no :tangle vector.tpp
namespace container {
template <typename T> Vector<T>::Vector() {
  _size = 0;
  _capacity = 8;
  _vector = new T[_capacity];
}

template <typename T> Vector<T>::~Vector() {
  delete[] _vector;
}

template <typename T> void Vector<T>::push_back(T e) {
  if (_size == _capacity) {
    _capacity *= 2;
    T *_new_vector = new T[_capacity];

    for (std::size_t i = 0; i < _size; i++) {
      _new_vector[i] = _vector[i];
    }

    delete[] _vector;
    _vector = _new_vector;
  }

  _vector[_size] = e;
  _size++;
}

template <typename T> T Vector<T>::at(std::size_t i) const {
  return _vector[i];
}
}
#+end_src

E agora vamos testar:

main.cpp

#+begin_src C++ :flags -std=c++17 -I.
#include <iostream>
#include "seq.hpp"

int main() {
  container::Vector<int> xs;
  
  for (unsigned i = 0; i < 10; i++) {
    xs.push_back(i);
  }

  std::cout << xs.at(8) << std::endl;
  return 0;
}
#+end_src

#+RESULTS:
: 8

Podemos ter o mesmo namespace separado em m√∫ltiplos arquivos

assoc.hpp (containers associativos)

#+begin_src C++ :main no :tangle assoc.hpp
#ifndef CONTAINER_ASSOC_H
#define CONTAINER_ASSOC_H

namespace container {
template <typename T>
class Set {
  // ...
};

template <typename K, T>
class Map {
  // ...
};
}

#endif
#+end_src

* Organiza√ß√£o do Projeto

A forma como estruturamos nosso projeto tamb√©m √© importante!

Nosso pr√≥ximo mini-projeto: um sistema de gerenciamento.

Vamos seguir (n√£o muito a risca, apenas para ilustrar) um padr√£o de projeto chamado DAO (Data Access Object), que consiste (bem por alto) em separar models (as entidades, que representam dados) da l√≥gica de persist√™ncia dos dados (em um banco de dados, no nosso caso um arquivo CSV).

A estrutura do projeto:

#+begin_example
book_management/
|__ include/
    |__ database/
        |__ csv.hpp
    |__ dao/
        |__ book.hpp
    |__ model/
        |__ book.hpp
|__ src/
    |__ database/
        |__ csv.cpp
    |__ dao/
        |__ book.cpp
    |__ main.cpp
|__ Makefile
#+end_example


Come√ßando do model Book:

include/model/book.hpp

#+begin_src C++
#ifndef MODEL_BOOK_H
#define MODEL_BOOK_H

#include <string>

namespace model {
struct Book {
  std::string name;
  std::string isbn;
};
}
#endif
#+end_src

A parte de armazenamento no CSV:

include/database/csv.hpp

#+begin_src C++
#ifndef DATABASE_CSV_H
#define DATABASE_CSV_H

#include <fstream>
#include <string>
#include <vector>

namespace database {
class CSV {
public:
  using Line = std::vector<std::string>;

  CSV(std::string file_path);
  ~CSV();

  std::vector<Line> get_lines();
  void write(const std::vector<Line> &lines);

private:
  std::ifstream _db_read;
  std::ofstream _db_write;
};
}

#endif 
#+end_src

E a implementa√ß√£o do CSV:

src/database/csv.cpp

#+begin_src C++
#include "database/csv.hpp"
#include <sstream>

namespace database {
CSV::CSV(std::string file_path)
  : _db_read(file_path),
    _db_write(file_path, std::ios::app) { }

CSV::~CSV() {
  _db_read.close();
  _db_write.close();
}

std::vector<CSV::Line> CSV::get_lines() {
  std::vector<Line> lines;
  std::string csv_line;

  while (std::getline(_db_read, csv_line)) {
    std::istringstream stream_line(csv_line);
    std::string field;
    Line line;

    while (std::getline(stream_line, field, ',')) {
      line.push_back(field);
    }

    lines.push_back(line);
  }

  _db_read.clear();
  _db_read.seekg(0);

  return lines;
}

void CSV::write(const std::vector<Line> &lines) {
  for (Line line : lines) {
    for (std::size_t i = 0; i < line.size(); i++) {
      std::string field = line[i];
      _db_write << field;
      if (i < line.size() - 1) _db_write << ',';
    }
      
    _db_write << std::endl;
  }
}
}
#+end_src

E conectando o modelo com a persist√™ncia dos dados:
- no m√©todo save, qual o efeito de retornar o pr√≥prio objeto Book?

include/dao/book.hpp

#+begin_src C++
#ifndef DAO_BOOK_H
#define DAO_BOOK_H

#include "database/csv.hpp"
#include "model/book.hpp"
#include <vector>

namespace dao {
class Book {
public:
  Book();
  ~Book();

  Book &save(model::Book book); 
  std::vector<model::Book> get_all() const;

private:
  std::size_t _new_begin;
  std::vector<model::Book> _books;
  database::CSV _db;
  
  void _fetch_all();
  void _persist();
};
}

#endif
#+end_src

src/dao/book.cpp

#+begin_src C++
#include "dao/book.hpp"

namespace dao {
Book::Book() : _db("/tmp/books.csv") { 
  _fetch_all();
  _new_begin = _books.size();
}

void Book::_fetch_all() {
  std::vector<database::CSV::Line> lines = _db.get_lines();
  for (database::CSV::Line line : lines) {
    model::Book book;
    book.name = line[0];
    book.isbn = line[1];
    _books.push_back(book);
  }
}

Book::~Book() {
  _persist();
}

void Book::_persist()  {
  std::vector<database::CSV::Line> lines;
  for (std::size_t i = _new_begin; i < _books.size(); i++) {
    model::Book book = _books[i];
    database::CSV::Line line;
    line.push_back(book.name);
    line.push_back(book.isbn);
    lines.push_back(line);
  }
  _db.write(lines);
}

Book &Book::save(model::Book book) {
  _books.push_back(book);
  return *this;
}

std::vector<model::Book> Book::get_all() const {
  return _books;
}
}
#+end_src

E a nossa aplica√ß√£o de fato (main):

main.cpp

#+begin_src C++
#include "dao/book.hpp"
#include "model/book.hpp"
#include <iostream>

int main() {
  dao::Book dao;
  dao.save({"Harry Potter e a Pedra Filosofal", "978-8532523051"})
     .save({"O Senhor dos An√©is: A Sociedade do Anel", "978-8533613379"});
  
  for (model::Book book : dao.get_all()) {
    std::cout << book.name << " (" << book.isbn << ")" << std::endl;
  }

  return 0;
}
#+end_src

* Compila√ß√£o

O processo de compila√ß√£o √© dividido em algumas etapas
- Pr√©-processamento
- Compila√ß√£o de cada unidade de tradu√ß√£o para um arquivo objeto, ainda n√£o execut√°vel (depend√™ncias n√£o resolvidas)
- Liga√ß√£o entre objetos para resolver depend√™ncia de bibliotecas

Quando fazemos =g++ -std=c++17 src/main.cpp src/database/csv.cpp src/dao/book.cpp -o main=, estamos contemplando todas estas etapas

Mas, note que seguindo este m√©todo qualquer altera√ß√£o em qualquer arquivo requer a recompila√ß√£o de *todos* os .cpp. Eu um projeto muito grande, isto pode ser muito ineficiente. Como resolver? Como recompilar apenas o que √© necess√°rio?

Ferramenta =make= + arquivo Makefile:
- Podemos definir vari√°veis
- O arquivo Makefile √© composto de targets (alvo)
- O primeiro target √© o padr√£o do make (se n√£o for expl√≠cito)

O arquivo Makefile √© composto de v√°rios targets, na forma

#+begin_src makefile
target: dependencia1 dependencia2 ... dependencia n
	comando1
	comando2
	...
	comandok
#+end_src

Por exemplo, podemos ter um target sem nenhuma depend√™ncia, que imprime uma mensagem na tela:

#+begin_src makefile
run: 
	echo "üöÄ Executing ..."
#+end_src

Para executar, basta fazer =make run= e o resultado √©

#+begin_example
echo "üöÄ Executing ..."
üöÄ Executing ...
#+end_example

Note que, al√©m da mensagem que gostar√≠amos que fosse mostrada, tamb√©m foi exibido o pr√≥prio comando que foi executado. Podemos suprimir essa informa√ß√£o adicional com um "@":

#+begin_src makefile
run: 
	@echo "üöÄ Executing ..."
#+end_src

E o resultado, com =make run=:

#+begin_example
üöÄ Executing ...
#+end_example

Caso execut√°ssemos apenas =make=, sem nenhum target, o target padr√£o √© o primeiro do arquivo (de cima para baixo). Como, neste primeiro momento, temos apenas um target, o efeito seria o mesmo.

At√© ent√£o, ainda n√£o fizemos nada de compila√ß√£o. Vamos tentar compilar o nosso projeto inteiro. O resultado ser√° um arquivo execut√°vel "main" (poderia ser qualquer outro nome, talvez book\under{}management) armazenado na pasta "bin/". Por conveni√™ncia, vamos definir o nome do target exatamente como o arquivo de sa√≠da: bin/main

#+begin_src makefile
bin/main:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p bin/
	g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main

run: 
	@echo "üöÄ Executing ..."
#+end_src

Note que agora o target padr√£o √© o =bin/main=, ou seja, =make= agora √© equivalente a =make bin/main=. E o resultado:

#+begin_example
üèõÔ∏èÔ∏è Building ...
g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main
#+end_example

Note que, se executar =make bin/main= novamente, a ferramenta make detecta que n√£o houveram altera√ß√µes, ent√£o n√£o h√° necessidade de recompilar o projeto novamente. E o resultado √©

#+begin_example
make: 'bin/main' is up to date.
#+end_example

Se estamos criando uma pasta, faz sentido querermos apag√°-la tamb√©m:

#+begin_src makefile
bin/main:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p bin/
	g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main

run: 
	@echo "üöÄ Executing ..."

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf bin/
#+end_src

Agora, basta executar =make clean= e a pasta bin/ ser√° deletada.

E para executar nosso programa?

#+begin_src makefile
bin/main:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p bin/
	g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main

run: 
	@echo "üöÄ Executing ..."
	@bin/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf bin/
#+end_src

E o resultado de =make run=:

#+begin_example
üöÄ Executing ...
Harry Potter e a Pedra Filosofal (978-8532523051)
O Senhor dos An√©is: A Sociedade do Anel (978-8533613379)
#+end_example

Note que estamos nos referindo a pasta "bin/" em mais de um lugar. E se quis√©ssemos alterar esta para uma outra pasta? Precisar√≠amos alterar v√°rias partes do Makefile. Ao inv√©s disso, podemos definir uma vari√°vel (e a√≠ bastaria alterar a vari√°vel):

#+begin_src makefile
BIN := bin

${BIN}/main:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o ${BIN}/main

run: 
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/
#+end_src

Vamos fazer o mesmo para as outras pastas, para o compilador (e se quiss√©ssemos futuramente usar outro compilador, talvez o clang++?), as flags que passamos para o compilador, etc:

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
EXEC := main

${BIN}/${EXEC}:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}

run: 
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/
#+end_src

E se tent√°ssemos rodar =make run= sem antes compilar o projeto? Ou, basicamente, =make clean= seguido por =make run=? O resultado

#+begin_example
üöÄ Executing ...
make: bin/main: No such file or directory
make: *** [Makefile:16: run] Error 127
#+end_example

O arquivo bin/main n√£o existe... Como garantir que, ao tentar executar o programa, ele estar√° compilado? Adicionamos uma depend√™ncia ao target run:

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
EXEC := main

${BIN}/${EXEC}:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/
#+end_src

J√° temos um Makefile funcional, mas ainda temos aquele problema de se atualizarmos algum dos arquivos, temos que recompilar o projeto inteiro. Vamos separar o processo de compila√ß√£o em v√°rias etapas. Primeiro, vamos construir o arquivo objeto do database/csv.cpp. Vamos armazenar esses arquivos objetos em uma pasta "build":

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

E agora para o dao/book.cpp. Note que este cara depende, tamb√©m, do model/book.hpp e database/csv.hpp (das interfaces):

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

Por fim, o √∫ltimo objeto referente ao src/main.cpp:

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}:
	@echo "üèõÔ∏è Ô∏è Building ..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o

${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
	@echo "üèõÔ∏è  Building main.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o ${BUILD}/main.o

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

Agora, precisamos ligar todos estes objetos. Vamos alterar o primeiro target. Quais as depend√™ncias? Os objetos!

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
	@echo "Ô∏èüîß Ô∏èInstalling ${EXEC}..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o ${BIN}/${EXEC}

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o

${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
	@echo "üèõÔ∏è  Building main.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o ${BUILD}/main.o

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

Estamos repetindo v√°rias coisas. Por exemplo, o nome dos targets e os arquivos de sa√≠da. Podemos simplificar.
- $@ equivale ao target

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
	@echo "Ô∏èüîß Ô∏èInstalling ${EXEC}..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o $@

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o $@

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o $@

${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
	@echo "üèõÔ∏è  Building main.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o $@

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

- $< equivale a primeira depend√™ncia da lista, que em muitos casos √© o arquivo .cpp que ir√° virar um objeto:
 
#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
	@echo "Ô∏èüîß Ô∏èInstalling ${EXEC}..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o $@

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
	@echo "üèõÔ∏è  Building main.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src
  
- $^ equivale as depend√™ncias, que estamos repetindo na etapa de liga√ß√£o dos objetos

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17

INCLUDE := include
SRC := src
BIN := bin
BUILD := build
EXEC := main

${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
	@echo "Ô∏èüîß Ô∏èInstalling ${EXEC}..."
	@mkdir -p ${BIN}/
	${CXX} ${CXXFLAGS} $^ -o $@

${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
	@echo "üèõÔ∏è Ô∏è Building db_csv.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
	@echo "üèõÔ∏è  Building dao_book.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
	@echo "üèõÔ∏è  Building main.o ..."
	@mkdir -p ${BUILD}
	${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@

run: ${BIN}/${EXEC}
	@echo "üöÄ Executing ..."
	@${BIN}/main

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf ${BIN}/ ${BUILD}/
#+end_src

E tem mais... √© poss√≠vel automatizar as depend√™ncias, simplificar outras coisas (vai ficando mais complexo). Mas, com o "b√°sico" voc√™s j√° conseguem automatizar muita coisa do processo de compila√ß√£o.
